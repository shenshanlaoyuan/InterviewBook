{"./":{"url":"./","title":"首页","keywords":"","body":"Java面试宝典 很多人面试之前没什么准备，也不知道从哪里开始复习，然而机会往往是给有准备的人。笔者根据多年工作经验，整理一份面试宝典，帮助大家快速突击复习和巩固面试常问的技术点，面试拿到心仪的offer。 1.基础篇 1.1.面向对象 1.1.1.什么是面向对象 面向对象、面向过程 面向对象的三大基本特征和五大基本原则 1.1.2.平台无关性 Java 如何实现的平台无关 JVM 还支持哪些语言（Kotlin、Groovy、JRuby、Jython、Scala） 1.1.3.值传递 值传递、引用传递 为什么说 Java 中只有值传递 1.1.4.封装、继承、多态 什么是多态、方法重写与重载 Java 的继承与实现 构造函数与默认构造函数 类变量、成员变量和局部变量 成员变量和方法作用域 1.2.Java基础知识 1.2.1.基本数据类型 8 种基本数据类型：整型、浮点型、布尔型、字符型 整型中 byte、short、int、long 的取值范围 什么是浮点型？什么是单精度和双精度？为什么不能用浮点型表示金额？ 1.2.2. 自动拆装箱 什么是包装类型、什么是基本类型、什么是自动拆装箱 Integer 的缓存机制 1.2.3.String 字符串的不可变性 JDK 6 和 JDK 7 中 substring 的原理及区别、 replaceFirst、replaceAll、replace 区别、 String 对“+”的重载、字符串拼接的几种方式和区别 String.valueOf 和 Integer.toString 的区别、 switch 对 String 的支持 字符串池、常量池（运行时常量池、Class 常量池）、intern 1.2.4.熟悉 Java 中各种关键字 transient、instanceof、final、static、volatile、synchronized、const 原理及用法 1.2.5.集合类 常用集合类的使用、ArrayList 和 LinkedList 和 Vector 的区别 、SynchronizedList 和 Vector 的区别、HashMap、HashTable、ConcurrentHashMap 区别、 Set 和 List 区别？Set 如何保证元素不重复？ Java 8 中 stream 相关用法、apache 集合处理工具类的使用、不同版本的 JDK 中 HashMap 的实现的区别以及原因 Collection 和 Collections 区别 Arrays.asList 获得的 List 使用时需要注意什么 Enumeration 和 Iterator 区别 fail-fast 和 fail-safe CopyOnWriteArrayList、ConcurrentSkipListMap 1.2.6.枚举 枚举的用法、枚举的实现、枚举与单例、Enum 类 Java 枚举如何比较 switch 对枚举的支持 枚举的序列化如何实现 枚举的线程安全性问题 1.2.7.IO 字符流、字节流、输入流、输出流、 同步、异步、阻塞、非阻塞、Linux 5 种 IO 模型 BIO、NIO 和 AIO 的区别、三种 IO 的用法与原理、netty 1.2.8.反射 反射与工厂模式、反射有什么用 Class 类、java.lang.reflect.* 1.2.9.动态代理 静态代理、动态代理 动态代理和反射的关系 动态代理的几种实现方式 AOP 1.2.10.序列化 什么是序列化与反序列化、为什么序列化、序列化底层原理、序列化与单例模式、protobuf、为什么说序列化并不安全 1.2.11.注解 元注解、自定义注解、Java 中常用注解使用、注解与反射的结合 Spring 常用注解 1.2.12.JMS 什么是 Java 消息服务、JMS 消息传送模型 1.2.13.JMX java.lang.management.、 javax.management. 1.2.14.泛型 泛型与继承、类型擦除、泛型中 KTVE? object 等的含义、泛型各种用法 限定通配符和非限定通配符、上下界限定符 extends 和 super List 和原始类型 List 之间的区别? List 和 List 之间的区别是什么? 1.2.15.单元测试 junit、mock、mockito、内存数据库（h2） 1.2.16.正则表达式 java.lang.util.regex.* 1.2.17.常用的 Java 工具库 commons.lang、commons.*...、 guava-libraries、 netty 1.2.18.API & SPI API、API 和 SPI 的关系和区别 如何定义 SPI、SPI 的实现原理 1.2.19.异常 异常类型、正确处理异常、自定义异常 Error 和 Exception 异常链、try-with-resources finally 和 return 的执行顺序 1.2.20.时间处理 时区、冬令时和夏令时、时间戳、Java 中时间 API 格林威治时间、CET,UTC,GMT,CST 几种常见时间的含义和关系 SimpleDateFormat 的线程安全性问题 Java 8 中的时间处理 如何在东八区的计算机上获取美国时间 1.2.21.编码方式 Unicode、有了 Unicode 为啥还需要 UTF-8 GBK、GB2312、GB18030 之间的区别 UTF8、UTF16、UTF32 区别 URL 编解码、Big Endian 和 Little Endian 如何解决乱码问题 1.2.22.语法糖 Java 中语法糖原理、解语法糖 语法糖：switch 支持 String 与枚举、泛型、自动装箱与拆箱、方法变长参数、枚举、内部类、条件编译、 断言、数值字面量、for-each、try-with-resource、Lambda 表达式 1.3.阅读源代码 String、Integer、Long、Enum、 BigDecimal、ThreadLocal、ClassLoader & URLClassLoader、 ArrayList & LinkedList、 HashMap & LinkedHashMap & TreeMap & CouncurrentHashMap、HashSet & LinkedHashSet & TreeSet 1.4.Java并发编程 1.4.1.并发与并行 什么是并发、什么是并行 并发与并行的区别 1.4.2.什么是线程，与进程的区别 线程的实现、线程的状态、优先级、线程调度、创建线程的多种方式、守护线程 线程与进程的区别 1.4.3.线程池 自己设计线程池、submit() 和 execute()、线程池原理 为什么不允许使用 Executors 创建线程池 1.4.4.线程安全 死锁、死锁如何排查、线程安全和内存模型的关系 1.4.5.锁 CAS、乐观锁与悲观锁、数据库相关锁机制、分布式锁、偏向锁、轻量级锁、重量级锁、monitor、 锁优化、锁消除、锁粗化、自旋锁、可重入锁、阻塞锁、死锁 1.4.6.死锁 什么是死锁 死锁如何解决 1.4.7.synchronized synchronized 是如何实现的？ synchronized 和 lock 之间关系、不使用 synchronized 如何实现一个线程安全的单例 synchronized 和原子性、可见性和有序性之间的关系 1.4.8.volatile happens-before、内存屏障、编译器指令重排和 CPU 指令重 volatile 的实现原理 volatile 和原子性、可见性和有序性之间的关系 有了 symchronized 为什么还需要 volatile 1.4.9.sleep 和 wait 1.4.10.wait 和 notify 1.4.11.notify 和 notifyAll 1.4.12.ThreadLocal 1.4.13.写一个死锁的程序 1.4.14.写代码来解决生产者消费者问题 1.4.15.并方包 Thread、Runnable、Callable、ReentrantLock、ReentrantReadWriteLock、Atomic*、Semaphore、CountDownLatch、ConcurrentHashMap、Executors 2.底层篇 2.1.JVM 2.1.1.JVM 内存结构 class 文件格式、运行时数据区：堆、栈、方法区、直接内存、运行时常量池、 堆和栈区别 Java 中的对象一定在堆上分配吗？ 2.1.2.Java 内存模型 计算机内存模型、缓存一致性、MESI 协议 可见性、原子性、顺序性、happens-before、 内存屏障、synchronized、volatile、final、锁 2.1.3.垃圾回收 GC 算法：标记清除、引用计数、复制、标记压缩、分代回收、增量式回收 GC 参数、对象存活的判定、垃圾收集器（CMS、G1、ZGC、Epsilon） 2.1.4.JVM 参数及调优 -Xmx、-Xmn、-Xms、Xss、-XX:SurvivorRatio、 -XX:PermSize、-XX:MaxPermSize、-XX:MaxTenuringThreshold 2.1.5.Java 对象模型 oop-klass、对象头 2.1.6.HotSpot 即时编译器、编译优化 2.1.7.虚拟机性能监控与故障处理工具 jps, jstack, jmap, jstat, jconsole, jinfo, jhat, javap, btrace, TProfiler Arthas 2.2.类加载机制 classLoader、类加载过程、双亲委派（破坏双亲委派）、模块化（jboss modules、osgi、jigsaw） 2.3.编译与反编译 什么是编译（前端编译、后端编译）、什么是反编译 JIT、JIT 优化（逃逸分析、栈上分配、标量替换、锁优化） 编译工具：javac 反编译工具：javap 、jad 、CRF 3.进阶篇 3.1.Java 底层知识 3.1.1.字节码、class 文件格式 3.1.2.CPU 缓存，L1，L2，L3 和伪共享 3.1.3.尾递归 3.1.4.位运算 用位运算实现加、减、乘、除、取余 3.2.设计模式 设计模式的六大原则： 开闭原则（Open Close Principle）、里氏代换原则（Liskov Substitution Principle）、依赖倒转原则（Dependence Inversion Principle） 接口隔离原则（Interface Segregation Principle）、迪米特法则（最少知道原则）（Demeter Principle）、合成复用原则（Composite Reuse Principle） 3.2.1.了解 23 种设计模式 创建型模式：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。 行为型模式：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter 模式）、状态模式、策略模式、职责链模式(责任链模式)、访问者模式。 3.2.2.会使用常用设计模式 单例的七种写法：懒汉——线程不安全、懒汉——线程安全、饿汉、饿汉——变种、静态内部类、枚举、双重校验锁 工厂模式、适配器模式、策略模式、模板方法模式、观察者模式、外观模式、代理模式等必会 3.2.3.不用 synchronized 和 lock，实现线程安全的单例模式 3.2.4.实现 AOP 3.2.5.实现 IOC 3.2.6.nio 和 reactor 设计模式 3.3.网络编程知识 3.3.1.tcp、udp、http、https 等常用协议 三次握手与四次关闭、流量控制和拥塞控制、OSI 七层模型、tcp 粘包与拆包 3.3.2.http/1.0 http/1.1 http/2 之前的区别 http 中 get 和 post 区别 常见的 web 请求返回的状态码 404、302、301、500分别代表什么 3.3.3.http/3 3.3.4.Java RMI，Socket，HttpClient 3.3.5. cookie 与 session cookie 被禁用，如何实现 session 3.3.6.用 Java 写一个简单的静态文件的 HTTP 服务器 3.3.7.了解 nginx 和 apache 服务器的特性并搭建一个对应的服务器 3.3.8.用 Java 实现 FTP、SMTP 协议 3.3.9.进程间通讯的方式 3.3.10.什么是 CDN？如何实现？ 3.3.11.DNS 什么是 DNS 、记录类型: A 记录、CNAME 记录、AAAA 记录等 域名解析、根域名服务器 DNS 污染、DNS 劫持、公共 DNS：114 DNS、Google DNS、OpenDNS 3.3.12.反向代理 正向代理、反向代理 反向代理服务器 3.4.框架知识 3.4.1.Servlet 生命周期 线程安全问题 filter 和 listener web.xml 中常用配置及作用 3.4.2.Hibernate 什么是 OR Mapping Hibernate 的懒加载 Hibernate 的缓存机制 Hibernate / Ibatis / MyBatis 之间的区别 3.4.3.Spring Bean 的初始化 AOP 原理 实现 Spring 的IOC Spring 四种依赖注入方式 3.4.4.Spring MVC 什么是 MVC Spring mvc 与 Struts mvc 的区别 3.4.5.Spring Boot Spring Boot 2.0、起步依赖、自动配置、 Spring Boot 的 starter 原理，自己实现一个 starter 3.4.6.Spring Security 3.4.7.Spring Cloud 服务发现与注册：Eureka、Zookeeper、Consul 负载均衡：Feign、Spring Cloud Loadbalance 服务配置：Spring Cloud Config 服务限流与熔断：Hystrix 服务链路追踪：Dapper 服务网关、安全、消息 3.5.应用服务器知识 3.5.1.JBoss 3.5.2.tomcat 3.5.3. jetty 3.5.4.Weblogic 3.6.工具 3.6.1.git & svn 3.6.2.maven & gradle 3.6.3.Intellij IDEA 常用插件：Maven Helper 、FindBugs-IDEA、阿里巴巴代码规约检测、GsonFormat Lombok plugin、.ignore、Mybatis plugin 4.高级篇 4.1.新技术 4.1.1.Java 8 lambda 表达式、Stream API、时间 API 4.1.2.Java 9 Jigsaw、Jshell、Reactive Streams 4.1.3.Java 10 局部变量类型推断、G1 的并行 Full GC、ThreadLocal 握手机制 4.1.4.Java 11 ZGC、Epsilon、增强 var 4.1.5.Spring 5 响应式编程 4.1.6.Spring Boot 2.0 4.1.7.HTTP/2 4.1.8.HTTP/3 4.2.性能优化 使用单例、使用 Future 模式、使用线程池 选择就绪、减少上下文切换、减少锁粒度、数据压缩、结果缓存 4.3.线上问题分析 4.3.1.dump 获取 线程 Dump、内存 Dump、gc 情况 4.3.2.dump 分析 分析死锁、分析内存泄露 4.3.3.dump 分析及获取工具 jstack、jstat、jmap、jhat、Arthas 4.3.4.自己编写各种 outofmemory，stackoverflow 程序 HeapOutOfMemory、 Young OutOfMemory、 MethodArea OutOfMemory、ConstantPool OutOfMemory、 DirectMemory OutOfMemory、Stack OutOfMemory Stack OverFlow 4.3.5.Arthas jvm 相关、class/classloader 相关、monitor/watch/trace 相关、 options、管道、后台异步任务 文档：https://alibaba.github.io/arthas/advanced-use.html 4.3.6.常见问题解决思路 内存溢出、线程死锁、类加载冲突 4.3.7.使用工具尝试解决以下问题，并写下总结 当一个 Java 程序响应很慢时如何查找问题 当一个 Java 程序频繁 FullGC 时如何解决问题 如何查看垃圾回收日志 当一个 Java 应用发生 OutOfMemory 时该如何解决 如何判断是否出现死锁 如何判断是否存在内存泄露 使用 Arthas 快速排查 Spring Boot 应用404/401问题 使用 Arthas 排查线上应用日志打满问题 利用 Arthas 排查 Spring Boot 应用 NoSuchMethodError 4.4.编译原理知识 4.4.1.编译与反编译 4.4.2.Java 代码的编译与反编译 4.4.3.Java 的反编译工具 javap 、jad 、CRF 4.4.4.即时编译器 4.4.5.编译过程 词法分析，语法分析（LL 算法，递归下降算法，LR 算法） 语义分析，运行时环境，中间代码，代码生成，代码优化 4.5.操作系统知识 4.5.1.Linux 的常用命令 4.5.2.进程间通信 4.5.3.进程同步 生产者消费者问题、哲学家就餐问题、读者写者问题 4.5.4.缓冲区溢出 4.5.5.分段和分页 4.5.6.虚拟内存与主存 4.5.7.虚拟内存管理 4.5.8.换页算法 4.6.数据库知识 4.6.1.MySQL 执行引擎 4.6.2.MySQL 执行计划 如何查看执行计划，如何根据执行计划进行 SQL 优化 4.6.3.索引 Hash 索引、B 树索引（B+树、和B树、R树） 普通索引、唯一索引 覆盖索引、最左前缀原则、索引下推 4.6.4.SQL 优化 4.6.5.数据库事务和隔离级别 事务的隔离级别、事务能不能实现锁的功能 4.6.7.数据库锁 行锁、表锁、使用数据库锁实现乐观锁、 4.6.8.连接 内连接，左连接，右连接 4.6.9.数据库主备搭建 4.6.10.binlog 4.6.11.redolog 4.6.12.内存数据库 h2 4.6.13.分库分表 4.6.14.读写分离 4.6.15.常用的 NoSql 数据库 redis、memcached 4.6.16.分别使用数据库锁、NoSql 实现分布式锁 4.6.17.性能调优 4.6.18.数据库连接池 4.7.数据结构与算法知识 4.7.1.简单的数据结构 栈、队列、链表、数组、哈希表、 栈和队列的相同和不同之处 栈通常采用的两种存储结构 4.7.2.树 二叉树、字典树、平衡树、排序树、 B 树、B+ 树、R 树、多路树、红黑树 4.7.3.堆 大根堆、小根堆 4.7.4.图 有向图、无向图、拓扑 4.7.5.排序算法 稳定的排序：冒泡排序、插入排序、鸡尾酒排序、桶排序、计数排序、归并排序、原地归并排序、二叉排序树排序、鸽巢排序、基数排序、侏儒排序、图书馆排序、块排序 不稳定的排序：选择排序、希尔排序、Clover 排序算法、梳排序、堆排序、平滑排序、快速排序、内省排序、耐心排序 各种排序算法和时间复杂度 4.7.6.两个栈实现队列，和两个队列实现栈 4.7.7.深度优先和广度优先搜索 4.7.8.全排列、贪心算法、KMP 算法、hash 算法 4.7.9.海量数据处理 分治，hash 映射，堆排序，双层桶划分，Bloom Filter，bitmap，数据库索引，mapreduce 等。 4.8.大数据知识 4.8.1.Zookeeper 基本概念、常见用法 4.8.2.Solr，Lucene，ElasticSearch 在 linux 上部署 solr，solrcloud，新增、删除、查询索引 4.8.3.Storm，流式计算，了解 Spark，S4 在 linux 上部署 storm，用 zookeeper 做协调，运行 storm hello world，local 和 remote 模式运行调试 storm topology。 4.8.4.Hadoop，离线计算 HDFS、MapReduce 4.8.5.分布式日志收集 flume，kafka，logstash 4.8.6.数据挖掘，mahout 4.9.网络安全知识 4.9.1.XSS XSS 的防御 4.9.2.CSRF 4.9.3.注入攻击 SQL 注入、XML 注入、CRLF 注入 4.9.4.文件上传漏洞 4.9.5.加密与解密 对称加密、非对称加密、哈希算法、加盐哈希算法 MD5，SHA1、DES、AES、RSA、DSA 彩虹表 4.9.6.DDOS攻击 DOS 攻击、DDOS 攻击 memcached 为什么可以导致 DDos 攻击、什么是反射型 DDoS 如何通过 Hash 碰撞进行 DOS 攻击 4.9.7.SSL、TLS，HTTPS 4.9.8.用 openssl 签一个证书部署到 apache 或 nginx 5.架构篇 5.1.分布式 数据一致性、服务治理、服务降级 5.1.1.分布式事务 2PC、3PC、CAP、BASE、 可靠消息最终一致性、最大努力通知、TCC 5.1.2.Dubbo 服务注册、服务发现，服务治理 http://dubbo.apache.org/zh-cn/ 5.1.3.分布式数据库 怎样打造一个分布式数据库、什么时候需要分布式数据库、 mycat、otter、HBase 5.1.4.分布式文件系统 mfs、fastdfs 5.1.5.分布式缓存 缓存一致性、缓存命中率、缓存冗余 5.1.6.限流降级 Hystrix、Sentinal 5.1.7.算法 共识算法、Raft 协议、Paxos 算法与 Raft 算法、 拜占庭问题与算法、2PC、3PC 5.2.微服务 SOA、康威定律 5.2.1.ServiceMesh sidecar 5.2.2.Docker & Kubernets 5.2.3.Spring Boot 5.2.4.Spring Cloud 5.3.高并发 5.3.1.分库分表 5.3.2.CDN 技术 5.3.3.消息队列 ActiveMQ 5.4. 监控 5.4.1.监控什么 CPU、内存、磁盘 I/O、网络 I/O 等 5.4.2.监控手段 进程监控、语义监控、机器资源监控、数据波动 5.4.3.监控数据采集 日志、埋点 5.4.4.Dapper 5.5.负载均衡 tomcat 负载均衡、Nginx 负载均衡 四层负载均衡、七层负载均衡 5.6.DNS DNS 原理、DNS 的设计 5.7.CDN 数据一致性 6.扩展篇 6.1.云计算 IaaS、SaaS、PaaS、虚拟化技术、openstack、Serverlsess 6.2.搜索引擎 Solr、Lucene、Nutch、Elasticsearch 6.3.权限管理 Shiro 6.4.区块链 哈希算法、Merkle 树、公钥密码算法、共识算法、 Raft 协议、Paxos 算法与 Raft 算法、拜占庭问题与算法、消息认证码与数字签名 比特币 挖矿、共识机制、闪电网络、侧链、热点问题、分叉 以太坊 超级账本 6.5.人工智能 数学基础、机器学习、人工神经网络、深度学习、应用场景。 常用框架 TensorFlow、DeepLearning4J Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-06-19 10:40:31 "},"基础篇/":{"url":"基础篇/","title":"基础篇","keywords":"","body":"基础篇 面向对象 基础知识 阅读源码 并发编程 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-05-30 15:38:06 "},"基础篇/面向对象/":{"url":"基础篇/面向对象/","title":"面向对象","keywords":"","body":"面向对象 什么是面向对象 平台无关性 值传递 封装、继承、多态 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-05-30 15:44:56 "},"基础篇/面向对象/什么是面向对象.html":{"url":"基础篇/面向对象/什么是面向对象.html","title":"什么是面向对象","keywords":"","body":"什么是面向对象 所谓的面向对象，就是在编程的时候尽可能的去模拟真实的现实世界，按照现实世界中的逻辑去处理一个问题，分析问题中参与其中的有哪些实体，这些实体应该有什么属性和方法，我们如何通过调用这些实体的属性和方法去解决问题。 什么是面向过程 面向过程是一种是事件为中心的编程思想。就是分析出解决问题所需的步骤，然后用函数把这写步骤实现，并按顺序调用。 面向对象的三大特性： 封装 隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。 继承 提高代码复用性；继承是多态的前提。 多态 父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。 五大基本原则： 单一职责原则SRP(Single Responsibility Principle) 类的功能要单一，不能包罗万象，跟杂货铺似的。 开放封闭原则OCP(Open－Close Principle) 一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万个不乐意。 里式替换原则LSP(the Liskov Substitution Principle LSP) 子类可以替换父类出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活。哈哈~~ 依赖倒置原则DIP(the Dependency Inversion Principle DIP) 高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的是抽象的中国人，而不是你是xx村的。 接口分离原则ISP(the Interface Segregation Principle ISP) 设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多。 参考文章 什么是面向对象（OOP） 编程思想：面向对象和面向过程 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-06-04 10:16:24 "},"基础篇/面向对象/平台无关性.html":{"url":"基础篇/面向对象/平台无关性.html","title":"平台无关性","keywords":"","body":"平台无关性 平台无关(跨平台): 一种语言在计算机上的运行不受平台的约束，一次编译到处运行。 Java 如何实现的平台无关 Java经过编译之后生成的.class 的字节码文件，运行平台上只要有JVM就能运行，不需要进行再次编译 JVM 还支持哪些语言 Kotlin、Groovy、JRuby、Jython、Scala 参考文章 Java不仅仅是Java：盘点运行在JVM下的其他9种语言 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-06-04 10:23:51 "},"基础篇/面向对象/值传递.html":{"url":"基础篇/面向对象/值传递.html","title":"值传递","keywords":"","body":"值传递 值传递和引用传递 值传递：(形式参数类型是基本数据类型)：方法调用时，实际参数把它的值传递给对应的形式参数，形式参数只是用实际参数的值初始化自己的存储单元内容，是两个不同的存储单元，所以方法执行中形式参数值的改变不影响实际参数的值。 引用传递：(形式参数类型是引用数据类型参数)：也称为传地址。方法调用时，实际参数是对象(或数组)，这时实际参数与形式参数指向同一个地址，在方法执行中，对形式参数的操作实际上就是对实际参数的操作，这个结果在方法结束后被保留了下来，所以方法执行中形式参数的改变将会影响实际参数。 为什么说 Java 中只有值传递 为什么说Java中只有值传递 参考文章 Java的值传递和引用传递 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-06-04 10:29:09 "},"基础篇/面向对象/封装继承多态.html":{"url":"基础篇/面向对象/封装继承多态.html","title":"封装、继承、多态","keywords":"","body":"封装、继承、多态 什么是多态 多态是同一个行为具有多个不同表现形式或形态的能力。 多态就是同一个接口，使用不同的实例而执行不同操作，如图所示 多态性是对象多种表现形式的体现。 方法重写与重载 方法重载（Overload）： 1.在同一个类中 2.方法名相同 3.参数的个数或类型不同 4.与方法的返回类型无关 5.与方法的修饰符无关 方法重写（Override）： 方法重写必须是子类继承父类，才能进行对父类的方法进行重写。 1.重写方法与被重写方法必须拥有相同的方法名 2.重写方法与被重写方法必须拥有相同的参数列表 3.重写方法的返回值类型必须与被重写方法的返回值类型相同 4.重写方法不能缩小被重写方法的访问权限 这里注意的是重写方法，必须是子类中能访问到的父类的方法。 方法重载与方法重写的区别： 1.重载是同一个类中的同名方法，要求方法名相同，参数列表不同，与返回值类型无关 2.重写涉及的是子类和父类之间的同名方法，要求方法名相同、参数列表相同、返回值类型相同 Java 的继承与实现 继承：如果多个类的某个部分的功能相同，那么可以抽象出一个类出来，把他们的相同部分都放到父类里，让他们都继承这个类。 实现：如果多个类处理的目标是一样的，但是处理的方法方式不同，那么就定义一个接口，也就是一个标准，让他们的实现这个接口，各自实现自己具体的处理方法来处理那个目标 参考文章 Java 方法重载与方法重写 Java继承与实现的区别与联系 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-06-05 10:05:59 "},"基础篇/基础知识/":{"url":"基础篇/基础知识/","title":"基础知识","keywords":"","body":"基础知识 基本数据类型 自动拆装箱 String 熟悉Java中各种关键字 集合类 枚举 IO 反射 动态代理 序列化 注解 JMS JMX 泛型 单元测试 正则表达式 常用的Java工具库 API&SPI 异常 时间处理 编码方式 语法糖 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-06-05 14:44:40 "},"基础篇/基础知识/基本数据类型.html":{"url":"基础篇/基础知识/基本数据类型.html","title":"基本数据类型","keywords":"","body":"基本数据类型 8种基本数据类型：byte，short，int，long，double，float，char，boolean， 基本类型 默认值 存储 对应的包装类 数据范围 byte 0 1个字节 java.lang.Byte [-2^7，2^7-1] int 0 4个字节 java.lang.Integer [-2^31，2^31-1] short 0 2个字节 java.lang.Short [-2^15，2^15-1] long 0L或0l 8个字节 java.lang.Long [-2^63，2^63-1] double 0.0或0.0D(d) 8个字节 java.lang.Double 64位IEEE 754双精度范围 float 0.0F或0.0f 4个字节 java.lang.Float 32位IEEE 754单精度范围 char ‘\\u0000’ 2个字节 java.lang.Character [0，2^16-1] boolean false 1个字节 java.lang.Boolean true\\false 为什么不能用浮点型表示金额？ 在java中，一般来说，我们的单精度float和双精度double已经可以满足我们的大部分需求了。但是不管是float和double都会出现浮点的误差，而这点误差在一般情况下并不影响我们的使用。 但是，在金融行业，一个小小的精度误差，可能会导致成千上万的损失，甚至严重点来说，可能会有牢狱之灾。因此，我们必须去严格的计算每一个小数点的值，不能出现任何误差。 也因此，出现了我们现在的这个问题，为什么不能用float和double等等等的浮点型来表示金额？ 参考文章 Java数据类型（整型，浮点型，字符型，布尔型） 为什么不能用浮点型表示金额？ Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-06-05 10:36:58 "},"基础篇/基础知识/自动拆装箱.html":{"url":"基础篇/基础知识/自动拆装箱.html","title":"自动拆装箱","keywords":"","body":"自动拆装箱 简单一点说，装箱就是 自动将基本数据类型转换为包装器类型；拆箱就是 自动将包装器类型转换为基本数据类型。 下表是基本数据类型对应的包装器类型： 基本数据类型 包装类型 int（4字节） Integer byte（1字节） Byte short（2字节） Short long（8字节） Long float（4字节） Float double（8字节） Double char（2字节） Character boolean（未定） Boolean 装箱和拆箱是如何实现的 我们就以Interger类为例，下面看一段代码： public class Main { public static void main(String[] args) { Integer i = 10; int n = i; } } 反编译class文件之后得到如下内容： 从反编译得到的字节码内容可以看出，在装箱的时候自动调用的是Integer的valueOf(int)方法。而在拆箱的时候自动调用的是Integer的intValue方法。 其他的也类似，比如Double、Character，不相信的朋友可以自己手动尝试一下。 因此可以用一句话总结装箱和拆箱的实现过程： 装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。（xxx代表对应的基本数据类型）。 Java Integer的缓存策略 本文将介绍 Java 中 Integer 缓存的相关知识。这是 Java 5 中引入的一个有助于节省内存、提高性能的特性。首先看一个使用 Integer 的示例代码，展示了 Integer 的缓存行为。接着我们将学习这种实现的原因和目的。你可以先猜猜下面 Java 程序的输出结果。很明显，这里有一些小陷阱，这也是我们写这篇文章的原因。 package com.javapapers.java; public class JavaIntegerCache { public static void main(String... strings) { Integer integer1 = 3; Integer integer2 = 3; if (integer1 == integer2) System.out.println(\"integer1 == integer2\"); else System.out.println(\"integer1 != integer2\"); Integer integer3 = 300; Integer integer4 = 300; if (integer3 == integer4) System.out.println(\"integer3 == integer4\"); else System.out.println(\"integer3 != integer4\"); } } 大多数人都认为上面的两个判断的结果都是 false。虽然它们的值相等，但由于比较的是对象，而对象的引用不一样，所以会认为两个 if 判断都是 false 的。在 Java 中，== 比较的是对象引用，而 equals 比较的是值。因此，在这个例子中，不同的对象有不同的引用，所以在进行比较的时候都应该返回 false。但是奇怪的是，这里两个相似的 if 条件判断却返回不同的布尔值。 下面是上面代码真正的输出结果， integer1 == integer2 integer3 != integer4 Java 中 Integer 缓存实现 在 Java 5 中，为 Integer 的操作引入了一个新的特性，用来节省内存和提高性能。整型对象在内部实现中通过使用相同的对象引用实现了缓存和重用。 上面的规则适用于整数区间 -128 到 +127。 这种 Integer 缓存策略仅在自动装箱（autoboxing）的时候有用，使用构造器创建的 Integer 对象不能被缓存。 Java 编译器把原始类型自动转换为封装类的过程称为自动装箱（autoboxing），这相当于调用 valueOf 方法 Integer a = 10; //this is autoboxing Integer b = Integer.valueOf(10); //under the hood 现在我们知道了 JDK 源码中对应实现的部分在哪里了。我们来看看 valueOf 的源码。下面是 JDK 1.8.0 build 25 中的代码。 /** * Returns an {@code Integer} instance representing the specified * {@code int} value. If a new {@code Integer} instance is not * required, this method should generally be used in preference to * the constructor {@link #Integer(int)}, as this method is likely * to yield significantly better space and time performance by * caching frequently requested values. * * This method will always cache values in the range -128 to 127, * inclusive, and may cache other values outside of this range. * * @param i an {@code int} value. * @return an {@code Integer} instance representing {@code i}. * @since 1.5 */ public static Integer valueOf(int i) { if (i >= IntegerCache.low && i 在创建新的 Integer 对象之前会先在 IntegerCache.cache 中查找。有一个专门的 Java 类来负责 Integer 的缓存。 IntegerCache 类 IntegerCache 是 Integer 类中一个私有的静态类。我们来看看这个类，有比较详细的文档，可以提供我们很多信息。 /** * Cache to support the object identity semantics of autoboxing for values between * -128 and 127 (inclusive) as required by JLS. * * The cache is initialized on first usage. The size of the cache * may be controlled by the {@code -XX:AutoBoxCacheMax=} option. * During VM initialization, java.lang.Integer.IntegerCache.high property * may be set and saved in the private system properties in the * sun.misc.VM class. */ private static class IntegerCache { static final int low = -128; static final int high; static final Integer cache[]; static { // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\"); if (integerCacheHighPropValue != null) { try { int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); } catch( NumberFormatException nfe) { // If the property cannot be parsed into an int, ignore it. } } high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k = 127; } private IntegerCache() {} } Javadoc 详细的说明这个类是用来实现缓存支持，并支持 -128 到 127 之间的自动装箱过程。最大值 127 可以通过 JVM 的启动参数 -XX:AutoBoxCacheMax=size 修改。 缓存通过一个 for 循环实现。从小到大的创建尽可能多的整数并存储在一个名为 cache 的整数数组中。这个缓存会在 Integer 类第一次被使用的时候被初始化出来。以后，就可以使用缓存中包含的实例对象，而不是创建一个新的实例(在自动装箱的情况下)。 实际上在 Java 5 中引入这个特性的时候，范围是固定的 -128 至 +127。后来在 Java 6 中，最大值映射到 java.lang.Integer.IntegerCache.high，可以使用 JVM 的启动参数设置最大值。这使我们可以根据应用程序的实际情况灵活地调整来提高性能。是什么原因选择这个 -128 到 127 这个范围呢？因为这个范围的整数值是使用最广泛的。 在程序中第一次使用 Integer 的时候也需要一定的额外时间来初始化这个缓存。 Java 语言规范中的缓存行为 在 Boxing Conversion 部分的Java语言规范(JLS)规定如下： 如果一个变量 p 的值属于：-128至127之间的整数(§3.10.1)，true 和 false的布尔值 (§3.10.3)，’u0000′ 至 ‘u007f’ 之间的字符(§3.10.4)中时，将 p 包装成 a 和 b 两个对象时，可以直接使用 a == b 判断 a 和 b 的值是否相等。 其他缓存的对象 这种缓存行为不仅适用于Integer对象。我们针对所有整数类型的类都有类似的缓存机制。 有 ByteCache 用于缓存 Byte 对象 有 ShortCache 用于缓存 Short 对象 有 LongCache 用于缓存 Long 对象 有 CharacterCache 用于缓存 Character 对象 Byte，Short，Long 有固定范围: -128 到 127。对于 Character, 范围是 0 到 127。除了 Integer 可以通过参数改变范围外，其它的都不行。 参考文章 深入剖析Java中的装箱和拆箱 Java Integer Cache Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-06-17 17:07:47 "},"基础篇/基础知识/String.html":{"url":"基础篇/基础知识/String.html","title":"String","keywords":"","body":"String 1. 字符串的不可变性 这里有一组图片来说明Java字符串的不可变性。 声明一个字符串 以下代码初始化了一个字符串s. String s = \"abcd\"; 如下所示，变量s储存了一个字符串对象的引用。箭头可以被当做“储存引用”。 将一个字符串变量分配给另一个字符串变量 下面代码将s分配给了s2. String s2 = s; s2储存了一个相同的引用值，因为它是同一个字符串对象。 合并字符串 当我们合并一个字符串”ef”到s， s = s.concat(\"ef\"); 如下所示，s存储新创建的字符串对象的引用： 总结 综上所述： 一旦在内存（堆）中创建了一个字符串，它就不能被改变。所有字符串的方法都没有去改变字符串自己，而是返回了一个新对象。 如果我们需要一个可以修改的字符串，我们将需要使用StringBuffer 或 StringBuilder. 否则，垃圾收集会浪费大量时间，因为每次创建一个新的字符串。 2. JDK 6 和 JDK 7 中 substring 的原理及区别 substring(int beginIndex, int endIndex)方法在不同版本的JDK中的实现是不同的。了解他们的区别可以帮助你更好的使用他。为简单起见，后文中用substring()代表substring(int beginIndex, int endIndex)方法。 substring() 的作用 substring(int beginIndex, int endIndex)方法截取字符串并返回其[beginIndex,endIndex-1]范围内的内容。 String x = \"abcdef\"; x = x.substring(1,3); System.out.println(x); 输出内容： bc 调用substring()时发生了什么？ 你可能知道，因为x是不可变的，当使用x.substring(1,3)对x赋值的时候，它会指向一个全新的字符串： 然而，这个图不是完全正确的表示堆中发生的事情。因为在jdk6 和 jdk7中调用substring时发生的事情并不一样。 JDK 6中的substring String是通过字符数组实现的。在jdk 6 中，String类包含三个成员变量：char value[]， int offset，int count。他们分别用来存储真正的字符数组，数组的第一个位置索引以及字符串中包含的字符个数。 当调用substring方法的时候，会创建一个新的string对象，但是这个string的值仍然指向堆中的同一个字符数组。这两个对象中只有count和offset 的值是不同的。 下面是证明上说观点的Java源码中的关键代码： //JDK 6 String(int offset, int count, char value[]) { this.value = value; this.offset = offset; this.count = count; } public String substring(int beginIndex, int endIndex) { //check boundary return new String(offset + beginIndex, endIndex - beginIndex, value); } JDK 6中的substring导致的问题 如果你有一个很长很长的字符串，但是当你使用substring进行切割的时候你只需要很短的一段。这可能导致性能问题，因为你需要的只是一小段字符序列，但是你却引用了整个字符串（因为这个非常长的字符数组一直在被引用，所以无法被回收，就可能导致内存泄露）。在JDK 6中，一般用以下方式来解决该问题，原理其实就是生成一个新的字符串并引用他。 x = x.substring(x, y) + \"\" 关于JDK 6中subString的使用不当会导致内存系列已经被官方记录在Java Bug Database中： 内存泄露：在计算机科学中，内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存。 内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。 JDK 7 中的substring 上面提到的问题，在jdk 7中得到解决。在jdk 7 中，substring方法会在堆内存中创建一个新的数组。 Java源码中关于这部分的主要代码如下： //JDK 7 public String(char value[], int offset, int count) { //check boundary this.value = Arrays.copyOfRange(value, offset, offset + count); } public String substring(int beginIndex, int endIndex) { //check boundary int subLen = endIndex - beginIndex; return new String(value, beginIndex, subLen); } 以上是JDK 7中的subString方法，其使用new String创建了一个新字符串，避免对老字符串的引用。从而解决了内存泄露问题。 所以，如果你的生产环境中使用的JDK版本小于1.7，当你使用String的subString方法时一定要注意，避免内存泄露。 3. replaceFirst、replaceAll、replace 区别 参考文章 Diagram to show Java String’s Immutability 三张图彻底了解JDK 6和JDK 7中substring的原理及区别 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-06-19 17:35:21 "},"基础篇/基础知识/熟悉Java中各种关键字.html":{"url":"基础篇/基础知识/熟悉Java中各种关键字.html","title":"熟悉Java中各种关键字","keywords":"","body":"熟悉Java中各种关键字 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-05-29 10:56:41 "},"基础篇/基础知识/集合类.html":{"url":"基础篇/基础知识/集合类.html","title":"集合类","keywords":"","body":"集合类 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-05-29 10:56:41 "},"基础篇/基础知识/枚举.html":{"url":"基础篇/基础知识/枚举.html","title":"枚举","keywords":"","body":"枚举 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-05-29 10:56:41 "},"基础篇/基础知识/IO.html":{"url":"基础篇/基础知识/IO.html","title":"IO","keywords":"","body":"IO Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-05-29 10:56:41 "},"基础篇/基础知识/反射.html":{"url":"基础篇/基础知识/反射.html","title":"反射","keywords":"","body":"反射 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-05-29 10:56:41 "},"基础篇/基础知识/动态代理.html":{"url":"基础篇/基础知识/动态代理.html","title":"动态代理","keywords":"","body":"动态代理 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-05-29 10:56:41 "},"基础篇/基础知识/序列化.html":{"url":"基础篇/基础知识/序列化.html","title":"序列化","keywords":"","body":"序列化 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-05-29 10:56:41 "},"基础篇/基础知识/注解.html":{"url":"基础篇/基础知识/注解.html","title":"注解","keywords":"","body":"注解 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-05-29 10:56:41 "},"基础篇/基础知识/JMS.html":{"url":"基础篇/基础知识/JMS.html","title":"JMS","keywords":"","body":"JMS Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-05-29 10:56:41 "},"基础篇/基础知识/JMX.html":{"url":"基础篇/基础知识/JMX.html","title":"JMX","keywords":"","body":"JMX Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-05-29 10:56:41 "},"基础篇/基础知识/泛型.html":{"url":"基础篇/基础知识/泛型.html","title":"泛型","keywords":"","body":"泛型 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-05-29 10:56:41 "},"基础篇/基础知识/单元测试.html":{"url":"基础篇/基础知识/单元测试.html","title":"单元测试","keywords":"","body":"单元测试 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-05-29 10:56:41 "},"基础篇/基础知识/正则表达式.html":{"url":"基础篇/基础知识/正则表达式.html","title":"正则表达式","keywords":"","body":"正则表达式 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-05-29 10:56:41 "},"基础篇/基础知识/常用的Java工具库.html":{"url":"基础篇/基础知识/常用的Java工具库.html","title":"常用的Java工具库","keywords":"","body":"常用的Java工具库 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-05-29 10:56:41 "},"基础篇/基础知识/API&SPI.html":{"url":"基础篇/基础知识/API&SPI.html","title":"API&SPI","keywords":"","body":"API&SPI Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-05-29 10:56:41 "},"基础篇/基础知识/异常.html":{"url":"基础篇/基础知识/异常.html","title":"异常","keywords":"","body":"异常 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-05-29 10:56:41 "},"基础篇/基础知识/时间处理.html":{"url":"基础篇/基础知识/时间处理.html","title":"时间处理","keywords":"","body":"时间处理 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-05-29 10:56:41 "},"基础篇/基础知识/编码方式.html":{"url":"基础篇/基础知识/编码方式.html","title":"编码方式","keywords":"","body":"编码方式 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-05-29 10:56:41 "},"基础篇/基础知识/语法糖.html":{"url":"基础篇/基础知识/语法糖.html","title":"语法糖","keywords":"","body":"语法糖 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-05-29 10:56:41 "},"基础篇/阅读源代码/":{"url":"基础篇/阅读源代码/","title":"阅读源代码","keywords":"","body":"阅读源代码 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-05-29 10:41:03 "},"基础篇/Java并发编程/":{"url":"基础篇/Java并发编程/","title":"并发编程","keywords":"","body":"Java并发编程 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-05-29 10:41:03 "},"基础篇/Java并发编程/并发与并行.html":{"url":"基础篇/Java并发编程/并发与并行.html","title":"并发与并行","keywords":"","body":"并发与并行 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-06-12 16:49:45 "},"基础篇/Java并发编程/什么是线程，与进程的区别.html":{"url":"基础篇/Java并发编程/什么是线程，与进程的区别.html","title":"什么是线程，与进程的区别","keywords":"","body":"什么是线程，与进程的区别 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-06-12 16:49:45 "},"基础篇/Java并发编程/线程池.html":{"url":"基础篇/Java并发编程/线程池.html","title":"线程池","keywords":"","body":"线程池 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-06-12 16:49:45 "},"基础篇/Java并发编程/线程安全.html":{"url":"基础篇/Java并发编程/线程安全.html","title":"线程安全","keywords":"","body":"线程安全 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-06-12 16:49:45 "},"基础篇/Java并发编程/锁.html":{"url":"基础篇/Java并发编程/锁.html","title":"锁","keywords":"","body":"锁 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-06-12 16:49:45 "},"基础篇/Java并发编程/死锁.html":{"url":"基础篇/Java并发编程/死锁.html","title":"死锁","keywords":"","body":"死锁 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-06-12 16:49:45 "},"基础篇/Java并发编程/synchronized.html":{"url":"基础篇/Java并发编程/synchronized.html","title":"synchronized","keywords":"","body":"synchronized Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-06-12 16:49:45 "},"基础篇/Java并发编程/volatile.html":{"url":"基础篇/Java并发编程/volatile.html","title":"volatile","keywords":"","body":"volatile Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-06-12 16:49:45 "},"基础篇/Java并发编程/sleep和wait.html":{"url":"基础篇/Java并发编程/sleep和wait.html","title":"sleep和wait","keywords":"","body":"sleep和wait Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-06-12 16:49:45 "},"基础篇/Java并发编程/wait和notify.html":{"url":"基础篇/Java并发编程/wait和notify.html","title":"wait和notify","keywords":"","body":"wait和notify Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-06-12 16:49:45 "},"基础篇/Java并发编程/notify和notifyAll.html":{"url":"基础篇/Java并发编程/notify和notifyAll.html","title":"notify和notifyAll","keywords":"","body":"notify和notifyAll Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-06-12 16:49:45 "},"基础篇/Java并发编程/ThreadLocal.html":{"url":"基础篇/Java并发编程/ThreadLocal.html","title":"ThreadLocal","keywords":"","body":"ThreadLocal Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-06-12 16:49:45 "},"基础篇/Java并发编程/写一个死锁的程序.html":{"url":"基础篇/Java并发编程/写一个死锁的程序.html","title":"写一个死锁的程序","keywords":"","body":"写一个死锁的程序 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-06-12 16:49:45 "},"基础篇/Java并发编程/写代码来解决生产者消费者问题.html":{"url":"基础篇/Java并发编程/写代码来解决生产者消费者问题.html","title":"写代码来解决生产者消费者问题","keywords":"","body":"写代码来解决生产者消费者问题 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-06-12 16:49:45 "},"基础篇/Java并发编程/并方包.html":{"url":"基础篇/Java并发编程/并方包.html","title":"并方包","keywords":"","body":"并方包 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-06-12 16:49:45 "},"底层篇/":{"url":"底层篇/","title":"底层篇","keywords":"","body":"底层篇 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-05-20 15:21:16 "},"底层篇/JVM/":{"url":"底层篇/JVM/","title":"JVM","keywords":"","body":"JVM Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-06-14 14:52:49 "},"底层篇/JVM/JVM内存结构.html":{"url":"底层篇/JVM/JVM内存结构.html","title":"JVM内存结构","keywords":"","body":"JVM内存结构 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-06-14 16:53:13 "},"底层篇/JVM/Java内存模型.html":{"url":"底层篇/JVM/Java内存模型.html","title":"Java内存模型","keywords":"","body":"Java内存模型 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-06-14 16:53:13 "},"底层篇/JVM/垃圾回收.html":{"url":"底层篇/JVM/垃圾回收.html","title":"垃圾回收","keywords":"","body":"垃圾回收 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-06-14 16:53:13 "},"底层篇/JVM/JVM参数及调优.html":{"url":"底层篇/JVM/JVM参数及调优.html","title":"JVM参数及调优","keywords":"","body":"JVM参数及调优 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-06-14 16:53:13 "},"底层篇/JVM/Java对象模型.html":{"url":"底层篇/JVM/Java对象模型.html","title":"Java对象模型","keywords":"","body":"Java对象模型 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-06-14 16:53:13 "},"底层篇/JVM/HotSpot.html":{"url":"底层篇/JVM/HotSpot.html","title":"HotSpot","keywords":"","body":"HotSpot Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-06-14 16:53:13 "},"底层篇/JVM/虚拟机性能监控与故障处理工具.html":{"url":"底层篇/JVM/虚拟机性能监控与故障处理工具.html","title":"虚拟机性能监控与故障处理工具","keywords":"","body":"虚拟机性能监控与故障处理工具 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-06-14 16:53:13 "},"底层篇/类加载机制/":{"url":"底层篇/类加载机制/","title":"类加载机制","keywords":"","body":"类加载机制 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-06-14 14:52:49 "},"底层篇/编译与反编译/":{"url":"底层篇/编译与反编译/","title":"编译与反编译","keywords":"","body":"编译与反编译 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-06-14 16:53:13 "},"进阶篇/":{"url":"进阶篇/","title":"进阶篇","keywords":"","body":"进阶篇 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-05-20 15:21:16 "},"进阶篇/Java底层知识/":{"url":"进阶篇/Java底层知识/","title":"Java底层知识","keywords":"","body":"Java底层知识 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-06-14 14:52:49 "},"进阶篇/设计模式/":{"url":"进阶篇/设计模式/","title":"设计模式","keywords":"","body":"设计模式 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-06-14 14:52:49 "},"进阶篇/网络编程知识/":{"url":"进阶篇/网络编程知识/","title":"网络编程知识","keywords":"","body":"网络编程知识 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-06-14 14:52:49 "},"进阶篇/框架知识/":{"url":"进阶篇/框架知识/","title":"框架知识","keywords":"","body":"框架知识 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-06-14 14:52:49 "},"进阶篇/应用服务器知识/":{"url":"进阶篇/应用服务器知识/","title":"应用服务器知识","keywords":"","body":"应用服务器知识 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-06-14 14:52:49 "},"进阶篇/工具/":{"url":"进阶篇/工具/","title":"工具","keywords":"","body":"工具 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-06-14 14:52:49 "},"高级篇/":{"url":"高级篇/","title":"高级篇","keywords":"","body":"高级篇 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-05-20 15:21:16 "},"架构篇/":{"url":"架构篇/","title":"架构篇","keywords":"","body":"架构篇 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-05-20 15:21:16 "},"扩展篇/":{"url":"扩展篇/","title":"扩展篇","keywords":"","body":"扩展篇 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-05-20 15:21:16 "},"推荐书籍/":{"url":"推荐书籍/","title":"推荐书籍","keywords":"","body":"推荐书籍 Copyright © 深山老猿 all right reserved，powered by Gitbook 文件最后修改时间： 2019-05-20 15:21:16 "}}